---
// 3D Logo component - liquid fill effect per letter
---

<div id="logo-3d-container" class="w-full h-full absolute inset-0 flex items-center justify-center pointer-events-none">
  <canvas id="logo-canvas" class="w-full h-full"></canvas>
</div>

<script>
  import * as THREE from 'three';
  import { FBXLoader } from 'three/examples/jsm/loaders/FBXLoader.js';

  const container = document.getElementById('logo-3d-container');
  const canvas = document.getElementById('logo-canvas') as HTMLCanvasElement;
  
  if (canvas && container) {
    // Scene
    const scene = new THREE.Scene();
    
    // Camera
    const camera = new THREE.PerspectiveCamera(
      45,
      container.clientWidth / container.clientHeight,
      0.1,
      1000
    );
    camera.position.set(0, 0, 35);  // Closer = bigger
    camera.lookAt(0, 0, 0);
    
    // Renderer
    const renderer = new THREE.WebGLRenderer({
      canvas,
      alpha: true,
      antialias: true
    });
    renderer.setSize(container.clientWidth, container.clientHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    
    // Load FBX
    const loader = new FBXLoader();
    const logoGroup = new THREE.Group();
    scene.add(logoGroup);
    
    // Shader uniforms
    const uniforms = {
      uTime: { value: 0 },
    };
    
    // Custom shader for liquid fill effect
    // Each "letter zone" has random timing, fills from bottom with wave distortion
    const fillVertexShader = `
      varying vec3 vPosition;
      varying vec3 vWorldPosition;
      void main() {
        vPosition = position;
        vec4 worldPos = modelMatrix * vec4(position, 1.0);
        vWorldPosition = worldPos.xyz;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `;
    
    const fillFragmentShader = `
      uniform float uTime;
      varying vec3 vPosition;
      varying vec3 vWorldPosition;
      
      // Pseudo-random based on position
      float random(vec2 st) {
        return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);
      }
      
      // Simplex-like noise for wave effect
      float noise(vec2 st) {
        vec2 i = floor(st);
        vec2 f = fract(st);
        float a = random(i);
        float b = random(i + vec2(1.0, 0.0));
        float c = random(i + vec2(0.0, 1.0));
        float d = random(i + vec2(1.0, 1.0));
        vec2 u = f * f * (3.0 - 2.0 * f);
        return mix(a, b, u.x) + (c - a)* u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
      }
      
      void main() {
        // Normalize positions
        float normalizedX = vWorldPosition.x / 30.0; // -1 to 1 roughly
        float normalizedY = vWorldPosition.y / 15.0; // -1 to 1 roughly
        
        // Create "letter zones" based on X position (11 letters in NOMUSICIANS)
        float letterIndex = floor((normalizedX + 1.0) * 5.5); // 0-10 for 11 letters
        
        // Random phase offset per letter zone
        float letterPhase = random(vec2(letterIndex * 0.1, 0.5)) * 6.28; // Full spread
        float letterSpeed = 0.3 + random(vec2(letterIndex * 0.2, 0.7)) * 0.15; // 0.3 to 0.45
        
        // Continuous movement using triangle wave (no flat spots like sin)
        float letterTime = uTime * letterSpeed + letterPhase;
        float triangleWave = abs(mod(letterTime * 0.08, 2.0) - 1.0); // 0 to 1 linear, no pauses
        
        // Limit range: never fully empty or full (25% to 75%)
        float fillCycle = 0.25 + triangleWave * 0.5;
        
        // Always-moving wave distortion (liquid surface)
        float waveFreq = 3.0;
        float waveAmp = 0.12;
        float wave = sin(normalizedX * waveFreq * 10.0 + uTime * 0.8) * waveAmp;
        wave += sin(normalizedX * waveFreq * 7.0 - uTime * 0.5) * waveAmp * 0.6;
        wave += sin(uTime * 0.3 + letterIndex) * 0.05; // Subtle breathing per letter
        
        // Fill from bottom (-1) to top (1) with limited range
        float fillLevel = -0.8 + fillCycle * 1.6; // Limited range
        fillLevel += wave;
        
        // Smooth edge for liquid surface
        float edgeWidth = 0.15;
        float fillAmount = smoothstep(fillLevel - edgeWidth, fillLevel + edgeWidth, normalizedY);
        fillAmount = 1.0 - fillAmount; // Invert: filled at bottom
        
        // Add slight shimmer/reflection effect
        float shimmer = noise(vec2(normalizedX * 20.0, normalizedY * 20.0 + uTime * 0.2)) * 0.15;
        fillAmount = clamp(fillAmount + shimmer * fillAmount, 0.0, 1.0);
        
        // Output
        gl_FragColor = vec4(1.0, 1.0, 1.0, fillAmount * 0.85);
      }
    `;
    
    // Wireframe shader
    const wireVertexShader = `
      varying vec3 vPosition;
      varying vec3 vWorldPosition;
      void main() {
        vPosition = position;
        vec4 worldPos = modelMatrix * vec4(position, 1.0);
        vWorldPosition = worldPos.xyz;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `;
    
    const wireFragmentShader = `
      uniform float uTime;
      varying vec3 vPosition;
      varying vec3 vWorldPosition;
      
      float random(vec2 st) {
        return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);
      }
      
      void main() {
        float normalizedX = vWorldPosition.x / 30.0;
        float normalizedY = vWorldPosition.y / 15.0;
        
        float letterIndex = floor((normalizedX + 1.0) * 5.5);
        float letterPhase = random(vec2(letterIndex * 0.1, 0.5)) * 6.28;
        float letterSpeed = 0.3 + random(vec2(letterIndex * 0.2, 0.7)) * 0.15;
        float letterTime = uTime * letterSpeed + letterPhase;
        float triangleWave = abs(mod(letterTime * 0.08, 2.0) - 1.0);
        float fillCycle = 0.25 + triangleWave * 0.5;
        
        float fillLevel = -0.8 + fillCycle * 1.6;
        float fillAmount = smoothstep(fillLevel - 0.15, fillLevel + 0.15, normalizedY);
        fillAmount = 1.0 - fillAmount;
        
        // Wireframe brighter where not filled
        float wireOpacity = 0.3 + (1.0 - fillAmount) * 0.6;
        gl_FragColor = vec4(1.0, 1.0, 1.0, wireOpacity);
      }
    `;
    
    loader.load('/logo-choy-2.fbx', (fbx) => {
      // Get bounding box for scaling
      const box = new THREE.Box3().setFromObject(fbx);
      const size = box.getSize(new THREE.Vector3());
      const center = box.getCenter(new THREE.Vector3());
      
      // Scale
      const maxDim = Math.max(size.x, size.y, size.z);
      const scale = 60 / maxDim;
      fbx.scale.setScalar(scale);
      
      // Center
      fbx.position.set(-center.x * scale, -center.y * scale, -center.z * scale);
      
      // Process each mesh
      fbx.traverse((child) => {
        if ((child as THREE.Mesh).isMesh) {
          const mesh = child as THREE.Mesh;
          
          // Create wireframe with shader
          const edges = new THREE.EdgesGeometry(mesh.geometry, 15);
          const wireMaterial = new THREE.ShaderMaterial({
            uniforms: uniforms,
            vertexShader: wireVertexShader,
            fragmentShader: wireFragmentShader,
            transparent: true,
            depthWrite: false,
          });
          const wireframe = new THREE.LineSegments(edges, wireMaterial);
          wireframe.position.copy(mesh.position);
          wireframe.rotation.copy(mesh.rotation);
          wireframe.scale.copy(mesh.scale);
          
          // Create fill mesh with shader
          const fillMaterial = new THREE.ShaderMaterial({
            uniforms: uniforms,
            vertexShader: fillVertexShader,
            fragmentShader: fillFragmentShader,
            transparent: true,
            side: THREE.DoubleSide,
            depthWrite: false,
          });
          const fillMesh = mesh.clone();
          fillMesh.material = fillMaterial;
          
          // Add to scene
          mesh.parent?.add(wireframe);
          mesh.parent?.add(fillMesh);
          mesh.visible = false;
        }
      });
      
      logoGroup.add(fbx);
      console.log('Logo loaded with liquid fill effect');
    });
    
    // Animation
    let time = 0;
    
    function animate() {
      requestAnimationFrame(animate);
      time += 0.016; // ~60fps
      
      uniforms.uTime.value = time;
      
      renderer.render(scene, camera);
    }
    
    animate();
    
    // Resize
    window.addEventListener('resize', () => {
      if (container) {
        camera.aspect = container.clientWidth / container.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(container.clientWidth, container.clientHeight);
      }
    });
  }
</script>

<style>
  #logo-3d-container {
    z-index: 20;
  }
  
  #logo-canvas {
    display: block;
  }
</style>
